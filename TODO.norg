* Now
  - (x) WASM basic linear memory example
  - (x) Single module request+metadata/response+metadata apis
  - ( ) Response metadata
  - ( ) Response buffer
  - ( ) Multi service messaging
  - ( ) Wrapper for rust (proc macro + lib)
  - ( ) Wrapper for JS (javy js lib?)
  - ( ) Wrapper for C (macro lib)
  - ( ) Network layer
  - ( ) Tests
  - ( ) Benchmarking

* Later
  - ( ) milliservice.yaml
  - ( ) Epoch based execution timeout
  - ( ) Environment labels - production/development
  - ( ) Versioning
  - ( ) Multiple request handlers (use `on_request` by default) (same module)
  - ( ) Multiple core instances or namespacing (for scoping)
  - ( ) Wrapper for Assemblyscript
  - ( ) Wrapper for Go
  - ( ) Wrapper for haskell
  - ( ) Wrapper for ocaml
  - ( ) Multithreading

* Links
  - {https://docs.wasmtime.dev/examples-rust-memory.html}
  - {https://docs.rs/wasmtime/12.0.1/wasmtime/struct.Memory.html#method.data}
  - {https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/index.html}
  - {https://github.com/pmalmgren/wasi-data-sharing/blob/shared-linear-memory-demo/examples/wasi/main.rs}
  - {https://www.fermyon.com/}
  - JS: {https://github.com/bytecodealliance/javy}
  - Go: {https://github.com/stealthrocket/wasi-go}
  - Ocaml: {https://github.com/ocsigen/js_of_ocaml}

* Pros
** vs monolith
   - Ease of deployment (faster shipping)
   - Programming language and technology agnostic
   - Easy versioning
   - Deployment has 0 downtime without scaling
   - Clear boundaries of ownership of services in teams
   - Security: Sandboxed environment for modules
** vs microservices
   - Easy versioning
   - Simple service discoverability
   - Non-flat architecture, can be scoped
   - You own the server
   - Lower up-front costs (dedicated instance)
   - Easy integration testing
   - Lower complexity
   - No network hop for cross-service communication

* Cons
** vs monolith
   - ?
** vs microservices
   - no fault isolation
   - not independently scalable

